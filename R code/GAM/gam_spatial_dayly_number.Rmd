---
title: "Nonparametric Analysis of UK Road Accidents"
subtitle: "dayly accidents using location"
author:
    - "Valeria Iapaolo"
    - "Oswaldo Morales"
    - "Riccardo Morandi"
    - "Abylai Orynbassar"
output:
    html_document:
        toc: true
        toc_float: true
        number_sections: true
    pdf_document:
        toc: true
        toc_depth: 3
        number_section: true
date: "2023-11-10"
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    #dev = c('pdf'),
    fig.align = 'center'
    #fig.path = 'output/',
    #fig.height = 6,
    #fig.width = 12
)
```

```{r libraries inclusions, include=FALSE}
library(tidyverse)
library(mgcv)
library(splines)
library(lubridate)
library(ggplot2)
library(conformalInference)
library(knitr)
library(sp)
library(rgl)
library(splines)
library(pbapply)
library(devtools)
library(visreg)
library(mgcViz)
```

```{r}
load("~/Documents/Nonparametric Statisics/Project/clean data/full_collisions.RData")
```

```{r}
glimpse(full_collisions)
```

for the location we have either latitude and longitude or the easting and northing osgr coordinates.

```{r}
dim(table(full_collisions$location_easting_osgr))

dim(table(full_collisions$location_northing_osgr))
```

too many

for latitude and longitude:

```{r}
dim(table(full_collisions$latitude))

dim(table(full_collisions$longitude))
```

this are basically unioque, we need to bin the locations using a grid.

```{r}
summary(full_collisions$latitude)

summary(full_collisions$longitude)
```

we bin the latitude and longitude an go from there.

dropping na's an selecting the spatial coordinates:

```{r}
df_spatial <- full_collisions %>% select(c(date,latitude,longitude)) %>% drop_na()
rm(full_collisions)
```

```{r}
range(df_spatial$latitude)
range(df_spatial$longitude)
```

a simple solution for the binning is to consider the latituded and logitude at by 
considering it to its first decimal figure, doing so we would get:

```{r}
n_lat <- ceiling((range(df_spatial$latitude)[2] - range(df_spatial$latitude)[1])*10)
n_lat

n_lon <- ceiling((range(df_spatial$longitude)[2] - range(df_spatial$longitude)[1])*10)
n_lon

n_tot <- n_lat*n_lon
n_tot
```

we have 10000 locations

```{r}
df_binned <- df_spatial %>% mutate(latitude_approx = ceiling(10*latitude)/10,longitude_approx = ceiling(10*longitude)/10)
```

we can now group by the latitude and longitude and see what happens:

```{r}
df_binned <- df_binned %>% group_by(latitude_approx,longitude_approx,date) %>% summarise(n = n()) %>% ungroup()
```

only 3369 of them have a t least a crash in them due to the geograaphy of the UK

```{r}
table(df_binned$n)
```
we can use this to build the model, only spatial for now:

```{r}
df_red <- df_binned %>% filter(lubridate::year(date) >= 2021)
```

(penalize thin plate splines)

```{r}
model <- gam(n ~ s(longitude_approx,latitude_approx), 
                data = df_red, family=poisson(), method='REML')

```

```{r}
summary(model)
```

```{r}
plot(model)
```

```{r}
plot(model,scheme=2,pages=0,select = 1,
main = "",
xlab = "longitude",ylab = "latitude")
```

```{r}
b <- getViz(model)
pl <- plot(sm(b, 1)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = map_data("world",region = "UK"),
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
pl
```


```{r}
plot(model,scheme=1,pages=0,select = 1,main = "", theta = 10, phi = 45,
xlab = "longitude",ylab = "latitude")
```


```{r}
vis.gam(model, view = c("longitude_approx", "latitude_approx"),
        plot.type = "persp", se = 2)
```

more spatial resolution would be better:

triyng thin plate splines

```{r}
model2 <- gam(n ~ s(longitude_approx,latitude_approx,bs = "tp", k = 50), 
                data = df_red, family=poisson(), method='REML')

```

```{r}
plot(model2,scheme=2,pages=0,select = 1,
main = "",
xlab = "longitude",ylab = "latitude")
```

```{r}
plot(model2,scheme=1,pages=0,select = 1,main = "", theta = 10, phi = 30,
xlab = "longitude",ylab = "latitude")
```


```{r}
b2 <- getViz(model2)
pl2 <- plot(sm(b2, 1)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = map_data("world",region = "UK"),
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
pl2
```

very good arround london, not good in the boundaries and elsewhere

trying with tensor product splines:

```{r}
model3 <- gam(n ~ te(longitude_approx,latitude_approx,bs = "cs", k = 10), 
                data = df_red, family=poisson(), method='REML')

```

```{r}
plot(model3,scheme=3,pages=0,select = 1,
main = "",
xlab = "longitude",ylab = "latitude")
```

```{r}
plot(model3,scheme=1,pages=0,select = 1,main = "", theta = 10, phi = 45,
xlab = "longitude",ylab = "latitude")
```


```{r}
b3 <- getViz(model3)
pl3 <- plot(sm(b3, 1)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = map_data("world",region = "UK"),
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
pl3
```

we needd a better cptrol on the begaviour at the boundaries

we can try ba additive models and then ading the interactios.

additive model:

```{r}
model_add <- gam(n ~ s(longitude_approx,k = 10)+ s(latitude_approx, k = 10), 
                data = df_red, family=poisson(), method='REML')

```

```{r}
summary(model_add)
```

```{r}
plot(model_add)
```

```{r}
plot(model_add,scheme=2,pages=0,
main = "",
xlab = "longitude",ylab = "latitude")
```



```{r}
b <- getViz(model_add)
pl <- plot(sm(b, 1)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = map_data("world",region = "UK"),
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
pl
```


```{r}
plot(model_add,scheme=1,pages=0,select = 1,main = "", theta = 10, phi = 45,
xlab = "longitude",ylab = "latitude")
```


```{r}
vis.gam(model_add, view = c("longitude_approx", "latitude_approx"),
        plot.type = "persp", se = 2,phi = 0,theta = 10)
```

model with innteractions:

```{r}
model_inter <- gam(n ~ s(longitude_approx,k = 10)+ s(latitude_approx, k = 10) + ti(longitude_approx,latitude_approx,k = 10), 
                data = df_red, family=poisson(), method='REML')

```

```{r}
summary(model_inter)
```

```{r}
plot(model_inter)
```

```{r}
plot(model_inter,scheme=2,pages=0,main = "",xlab = "longitude",ylab = "latitude")
```

```{r}
b <- getViz(model_inter)
pl <- plot(sm(b, 3)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = map_data("world",region = "UK"),
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
pl
```


```{r}
plot(model_inter,scheme=1,pages=0,select = 3,main = "", theta = 10, phi = 45,
xlab = "longitude",ylab = "latitude")
```


```{r}
vis.gam(model_inter, view = c("longitude_approx", "latitude_approx"),
        plot.type = "persp", se = 0,phi = 30,theta = 10)
```
something is wrong,

also we should be bounded to a smaller part when plotting since we don't have all the info

improving the best model:

```{r}
modeltp <- gam(n ~ s(longitude_approx,latitude_approx,bs = "tp", k = 75), 
                data = df_red, family=poisson(), method='REML')

```

```{r}
plot(modeltp,scheme=2,pages=0,select = 1,main = "",xlab = "longitude",ylab = "latitude")
```

```{r}
plot(modeltp,scheme=1,pages=0,select = 1,main = "", theta = 10, phi = 30,
xlab = "longitude",ylab = "latitude")
```


```{r}
btp <- getViz(modeltp)
pltp <- plot(sm(btp, 1)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = map_data("world",region = "UK"),
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
pltp
```

```{r}
geom_map <- map_data("world",region = "UK") %>% filter(!(subregion %in% c("Northern Ireland")))

geom_map_no_islands <- geom_map %>% filter(group == 15)
```


```{r}
geom_map %>% filter(!(group %in% c(4))) %>% ggplot() + 
  geom_polygon(aes(long,lat,group = group),fill = NA,color="black",lwd = 0.75,inherit.aes = F) + 
  coord_fixed(ratio=1)
```

we can try to cut the island out at the top which seem to creaate problems:

```{r}
max_lat <- range(geom_map_no_islands$lat)
max_lat

max_lon <- range(geom_map_no_islands$long)
max_lon
```

this will allow is to get a better result since avoiding the extremes:

```{r}
df_spatial2 <- df_spatial %>% filter(latitude <= max_lat[2] & latitude >= max_lat[1] &
                                       longitude <= max_lon[2] & longitude >= max_lon[1])
```

we lost only 3000 crashesbut the longitude is much smaler in range

```{r}
df_binned2 <- df_spatial2 %>% mutate(latitude_approx = ceiling(10*latitude)/10,longitude_approx = ceiling(10*longitude)/10) %>% group_by(latitude_approx,longitude_approx,date) %>% summarise(n = n()) %>% ungroup()
```

```{r}
df_red2 <- df_binned2 %>% filter(lubridate::year(date) >= 2021)
```

```{r}
modeltp <- gam(n ~ s(longitude_approx,latitude_approx,bs = "tp", k = 75), 
                data = df_red2, family=poisson(), method='REML')

```

```{r}
plot(modeltp,scheme=3,pages=0,select = 1,main = "",xlab = "longitude",ylab = "latitude")
```

```{r}
plot(modeltp,scheme=1,pages=0,select = 1,main = "", theta = 10, phi = 30,
xlab = "longitude",ylab = "latitude")
```


```{r}
btp <- getViz(modeltp)
pltp <- plot(sm(btp, 1)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = map_data("world",region = "UK"),
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
pltp
```

better behaved at the top border

```{r}
geom_map_red <- geom_map %>% filter(lat <= max_lat[2] & lat >= max_lat[1] &
                                       long <= max_lon[2] & long >= max_lon[1])
```


```{r}
plot(sm(btp, 1)) + l_fitRaster() + l_fitContour() +
    geom_polygon(data = geom_map_red,
                 aes(x=long, y = lat,group=group),
               fill=NA,color="black",lwd = 0.75,inherit.aes = F) +
  xlab("Longitude") + ylab("Latitude") + ggtitle("spatial component") + coord_fixed(ratio=1)
```

need to find the location of big cities and see how they do:

```{r}
world_cities <- read.csv("/Users/macbookpro/Documents/Nonparametric Statisics/Project/raw data/worldcities.csv")
```

selecting the biggest cities:

```{r}
uk_cities <- world_cities %>% filter(country == "United Kingdom")

cities <- uk_cities %>% select(c(city,lat,lng,population)) %>% filter(population > 150000) %>% 
  filter(city != "Belfast")
```

```{r}
geom_map_no_islands %>% ggplot() + 
  geom_polygon(aes(long,lat,group = group),fill = NA,color="black",lwd = 0.75,inherit.aes = F) + 
  coord_fixed(ratio=1) + geom_point(data = cities, mapping = aes(x=lng, y = lat,size = population),colour = "blue") 
```

takig this into account the model is very good as far as fitting goes.



