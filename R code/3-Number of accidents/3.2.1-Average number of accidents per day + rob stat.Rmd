---
title: "Nonparametric Analysis of UK Road Accidents"
subtitle: "Average number of accidents per day + rob stat"
author:
    - "Valeria Iapaolo"
    - "Oswaldo Morales"
    - "Riccardo Morandi"
    - "Abylai Orynbassar"
output:
    html_document:
        toc: true
        toc_float: true
        number_sections: true
    pdf_document:
        toc: true
        toc_depth: 3
        number_section: true
date: "2024-02-10"
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    #dev = c('pdf'),
    fig.align = 'center',
    #fig.path = 'output/',
    fig.height = 6,
    fig.width = 12
)
```


```{r libraries inclusions, include=FALSE}
library(tidyverse)
library(mgcv)
library(splines)
library(lubridate)
library(ggplot2)
library(conformalInference)
library(knitr)
library(robustbase)
library(robust)
```

We load the dataset containing the collisions.

```{r}
load("C:/Users/ipval/Desktop/Dataset NP/full_collisions.RData")

```

Let's have a look

```{r}
glimpse(full_collisions)
```

The aim of this section is to analyse the average number of collisions per day (averaging on the districts). So we begin by computing this quantity.

Let's look first to the local authority district
```{r}

full_collisions <- full_collisions[!is.na(full_collisions$local_authority_district), ]

nlevels(full_collisions$local_authority_district)
```

There are 416 districts.


Now we have a look to the weather conditions
```{r}
levels(full_collisions$weather_conditions)
full_collisions <- full_collisions %>%
  filter(!(weather_conditions %in% c("Data missing or out of range", "Unknown","Other")))
table(full_collisions$weather_conditions)
```

Now we create 2 new variables called 'wind' and 'rainfall' that specify the weather conditions.
```{r}

full_collisions <- full_collisions %>%
  mutate(
    wind = case_when(
      weather_conditions %in% c("Fine + high winds", "Raining + high winds",
                                             "Snowing + high winds") ~ "High winds",
      weather_conditions %in% c("Fine no high winds", "Raining no high winds",
                                             "Snowing no high winds","Fog or mist") ~ "No high winds"
      
    ),
    rainfall = case_when(
      weather_conditions %in% c("Raining + high winds", "Raining no high winds") ~ "Raining",
      weather_conditions %in% c("Snowing + high winds", "Snowing no high winds") ~ "Snowing",
      weather_conditions %in% c("Fine + high winds", "Fine no high winds") ~ "Fine",
      weather_conditions %in% c("Fog or mist") ~ "Fog"
    )
  )

```

Now we count the average number of accidents per day computing also the most common weather conditions in UK in this specific day.

```{r}
average_collisions_per_day <- full_collisions %>%
  group_by(datetime_date = as.Date(datetime), local_authority_district) %>%
  summarise(number_of_collisions = n(),
            most_common_wind = names(sort(table(wind), decreasing = TRUE)[1]),
            most_common_rainfall = names(sort(table(rainfall), decreasing = TRUE)[1])
  ) %>%
  group_by(datetime_date) %>%
  summarise(average_number_of_collisions = mean(number_of_collisions),
            most_common_wind = most_common_wind[1],
            most_common_rainfall = most_common_rainfall[1]
  )


average_collisions_per_day <- average_collisions_per_day %>%
  mutate(
    year = lubridate::year(datetime_date),
    day_of_the_year = lubridate::yday(datetime_date),
    day_type = ifelse(weekdays(datetime_date) %in% c("sabato", "domenica"), "weekend", "weekday")
  )

average_collisions_per_day$day_type<-factor(average_collisions_per_day$day_type)
average_collisions_per_day$most_common_rainfall<-factor(average_collisions_per_day$most_common_rainfall)
average_collisions_per_day$most_common_wind<-factor(average_collisions_per_day$most_common_wind)

```

Let's take a look at the dataset we just created

```{r}
glimpse(average_collisions_per_day)
```

```{r}
#save(average_collisions_per_day,file = "average_collisions_per_day.RData")
```

```{r}
load("C:/Users/ipval/Desktop/Dataset NP/average_collisions_per_day.RData")
```

```{r}
hist(average_collisions_per_day$average_number_of_collisions)
```
```{r}
shapiro.test(average_collisions_per_day$average_number_of_collisions[1:365*4])
```



```{r}

lm_model <- lm(average_number_of_collisions ~ day_type + most_common_wind + most_common_rainfall +
                      year + ns(day_of_the_year, df=7),
                      data = average_collisions_per_day)

```

```{r}
summary(lm_model)
```
```{r}
# Genera dati di predizione per day_of_the_year
new_data <- data.frame(day_type = "weekend",  # sostituisci con il valore desiderato
                       most_common_wind = "No high winds",  # sostituisci con il valore desiderato
                       most_common_rainfall = "Raining",  # sostituisci con il valore desiderato
                       year = 2005,  # sostituisci con il valore desiderato
                       day_of_the_year = seq(min(average_collisions_per_day$day_of_the_year),
                                             max(average_collisions_per_day$day_of_the_year), length.out = 100))

# Calcola i valori predetti
predicted_values <- predict(lm_model, newdata = new_data)

# Crea un grafico della parte non parametrica
plot(new_data$day_of_the_year, predicted_values, 
     xlab = "Day of the Year", ylab = "Average Number of Collisions", main = "Nonparametric Part of the Model")



```

```{r}
plot(lm_model)
```


Now we use the function "lmrob" to fit the same model in a robust way.


```{r}

model_robust <- lmrob(average_number_of_collisions ~ day_type + most_common_wind + most_common_rainfall +
                      year + ns(day_of_the_year, df=7),
                      data = average_collisions_per_day,
                      init='M-S',
                      control = lmrob.control(fast.s.large.n = Inf))

```

```{r}
summary(model_robust)
```
```{r}
# Genera dati di predizione per day_of_the_year
new_data <- data.frame(day_type = "weekend",  # sostituisci con il valore desiderato
                       most_common_wind = "No high winds",  # sostituisci con il valore desiderato
                       most_common_rainfall = "Raining",  # sostituisci con il valore desiderato
                       year = 2005,  # sostituisci con il valore desiderato
                       day_of_the_year = seq(min(average_collisions_per_day$day_of_the_year),
                                             max(average_collisions_per_day$day_of_the_year), length.out = 100))

# Calcola i valori predetti
predicted_values <- predict(model_robust, newdata = new_data)


# Crea un grafico della parte non parametrica con ggplot
ggplot(data = data.frame(Day_of_the_Year = new_data$day_of_the_year, Predicted_Values = predicted_values)) +
  geom_point(aes(x = Day_of_the_Year, y = Predicted_Values), color = "blue", alpha = 0.7) +
  labs(x = "Day of the Year", y = "Average Number of Collisions", 
       title = "Nonparametric Part of the Model") 



```

```{r}
plot(model_robust)
```
```{r}
leverage_threshold <- 2 * length(coefficients(model_robust)) / dim(average_collisions_per_day)[1]
leverage_threshold
```

```{r}
# Ottieni i residui stimati
residuals <- resid(model_robust)



# Crea un outlier map con ggplot
ggplot(data = data.frame(MD = model_robust$MD, Residuals = scale(residuals))) +
  geom_point(aes(x = MD, y = Residuals), 
             color = "blue", alpha = 0.7) +
  labs(x = "Robust distances", y = "Standardized residuals", 
       title = "Outlier map") +
  
  # Aggiungi linee di riferimento per identificare gli outlier
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_hline(yintercept = 2.5, linetype = "dashed", color = "red") +
  geom_hline(yintercept = -2.5, linetype = "dashed", color = "red") +
  geom_vline(xintercept = leverage_threshold, linetype = "dashed", color = "red")

```


Vertical outliers:
```{r}
which(abs(scale(residuals))>2.5)
```

Primo vertical outlier:

```{r}
average_collisions_per_day[5562,]$datetime_date
```
The full lockdown was officially announced on March 23, 2020, by Prime Minister Boris Johnson.

On March 23, 2020, the UK government imposed a series of restrictions, including the closure of many non-essential businesses, limiting people's movements, and prohibiting social gatherings. 


Point with highest standardized residual:
```{r}
average_collisions_per_day[5908,]$datetime_date

```


Good leverage points:

```{r}
which(model_robust$MD>leverage_threshold & abs(scale(residuals))<2.5)
```

In February 2017, the UK experienced an unusually long and intense cold wave with significant snowfall, especially in northern and eastern regions.

Bad leverage points:
```{r}
which(model_robust$MD>leverage_threshold & abs(scale(residuals))>2.5)
```


Now we identify the outliers and we check if the residuals are gaussian distributed

```{r}
outliers=which(model_robust$MD>leverage_threshold | abs(scale(residuals))>2.5)

qqnorm(residuals[-outliers])
qqline(residuals[-outliers])
```

```{r}
set.seed(12)
shapiro.test(sample(residuals,1000))
shapiro.test(sample(residuals[-outliers],1000))
```
```{r}

# Creare il primo istogramma con tutti i residui
plot1 <- ggplot(data = data.frame(Residuals = residuals), aes(x = Residuals)) +
  geom_histogram( binwidth =0.05,fill = "lightblue", color = "black") +
  labs(title = "Histogram of all residuals", x = "Residuals", y = "Frequency")+
coord_cartesian(xlim = c(-0.8,0.8),ylim=c(0,900))

# Creare il secondo istogramma escludendo gli outliers
plot2 <- ggplot(data = data.frame(Residuals = residuals[-outliers]), aes(x = Residuals)) +
  geom_histogram( binwidth =0.05,fill = "lightgreen", color = "black") +
  labs(title = "Histogram of non outlying residuals", x = "Residuals", y = "Frequency")+
  coord_cartesian(xlim = c(-0.8,0.8),ylim=c(0,900))

# Unire i due istogrammi affiancati
gridExtra::grid.arrange(plot1, plot2, ncol = 2)

```





Let's make a comparison of the coefficients of the two models


```{r}
coefficients(lm_model)

```

```{r}
coefficients(model_robust)
```



```{r}
data =average_collisions_per_day
fattore = data$most_common_wind
risposta = data$average_number_of_collisions
g <- nlevels(fattore)
n <- dim(data)[1]

#H_0: tau_i=0 for all i   vs    H_1:exists tau_i!=0

fit <- lm(risposta ~ fattore)
summary(fit)
T0 <- summary(fit)$fstatistic[1]  # extract the test statistic
T0

y.fitted <- mean(risposta)
residuals.H0 <- risposta - y.fitted

B=1000

T_stat <- numeric(B) 
n <- dim(data)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n, replace = T)
  residuals.perm <- residuals.H0[permutation]
  y.perm <- y.fitted + residuals.perm
  fit_perm <- lm(y.perm ~ fattore)
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)$fstatistic[1]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,
     main="Bootstrap distribution of T0 under H_0")
abline(v=T0,col=3,lwd=2)



```


```{r}

p_val <- sum(T_stat>=T0)/B
p_val

```
High p-value. The factor most_common_wind is not significant



```{r}
data =average_collisions_per_day
fattore = data$most_common_rainfall
risposta = data$average_number_of_collisions
g <- nlevels(fattore)
n <- dim(data)[1]

#H_0: tau_i=0 for all i   vs    H_1:exists tau_i!=0

fit <- lm(risposta ~ fattore)
summary(fit)
T0 <- summary(fit)$fstatistic[1]  # extract the test statistic
T0

y.fitted <- mean(risposta)
residuals.H0 <- risposta - y.fitted

B=1000

T_stat <- numeric(B) 
n <- dim(data)[1]

for(perm in 1:B){
  # Permutation:
  permutation <- sample(1:n, replace = T)
  residuals.perm <- residuals.H0[permutation]
  y.perm <- y.fitted + residuals.perm
  fit_perm <- lm(y.perm ~ fattore)
  # Test statistic:
  T_stat[perm] <- summary(fit_perm)$fstatistic[1]
}

hist(T_stat,xlim=range(c(T_stat,T0)),breaks=30,
     main="Bootstrap distribution of T0 under H_0")
abline(v=T0,col=3,lwd=2)



```


```{r}

p_val <- sum(T_stat>=T0)/B
p_val

```
Small p-value --> most_common_rainfall is significant








```{r}
# Converti variabili categoriche in dummies
dummy_vars <- model.matrix(~ day_type + most_common_wind + most_common_rainfall, data = average_collisions_per_day)

# Combina dummies con il dataframe originale
model_data <- cbind(average_collisions_per_day, dummy_vars)

# Adatta il modello robusto con le dummies
model_robust <- lmrob(average_number_of_collisions ~ day_type + most_common_wind + most_common_rainfall + ns(day_of_the_year, df = 7),
                      data = model_data, fast.s.large.n = Inf)

# Visualizza il plot
plot(model_robust)

```

Vertical outliers:

```{r}
which(model_robust$MD<0.0005)
```
Primo vertical outlier:

```{r}
average_collisions_per_day[5562,]$datetime_date
```
The full lockdown was officially announced on March 23, 2020, by Prime Minister Boris Johnson.

On March 23, 2020, the UK government imposed a series of restrictions, including the closure of many non-essential businesses, limiting people's movements, and prohibiting social gatherings. 


```{r}
leverage_threshold <- 2 * length(coefficients(model_robust)) / dim(average_collisions_per_day)[1]
leverage_threshold
```

Good leverage points:

```{r}
which(model_robust$MD>leverage_threshold)
```

Non ci sono bad leverage points infatti fittando il modello in modo non robusto i segni dei coefficienti del modello non cambiano
